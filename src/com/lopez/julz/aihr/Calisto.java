/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.lopez.julz.aihr;

import com.lopez.julz.aihr.dao.Attendance;
import com.lopez.julz.aihr.dao.AttendanceDao;
import com.lopez.julz.aihr.dao.BiometricUsers;
import com.lopez.julz.aihr.dao.BiometricUsersDao;
import com.lopez.julz.aihr.dao.DatabaseConnection;
import com.lopez.julz.aihr.dao.Employees;
import com.lopez.julz.aihr.dao.EmployeesDao;
import com.lopez.julz.aihr.dao.LeaveBalanceDetails;
import com.lopez.julz.aihr.dao.LeaveBalanceDetailsDao;
import com.lopez.julz.aihr.dao.LeaveBalances;
import com.lopez.julz.aihr.dao.LeaveBalancesDao;
import com.lopez.julz.aihr.dao.PayrollSchedules;
import com.lopez.julz.aihr.dao.PayrollSchedulesDao;
import com.lopez.julz.aihr.helpers.IDGenerator;
import com.lopez.julz.aihr.helpers.Notifiers;
import com.lopez.julz.aihr.pojos.AttendanceResponse;
import com.lopez.julz.aihr.pojos.BiometricUsersResponse;
import java.awt.Color;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.DefaultCaret;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

/**
 *
 * @author Julio Lopez
 */
public class Calisto extends javax.swing.JFrame {

    /**
     * Creates new form Calisto
     */
    public DatabaseConnection db;
    public Connection connection;
    
    public RetrofitBuilder retrofitBuilder;
    private RequestPlaceHolder requestPlaceHolder;
    
    public List<BiometricUsers> usersList;
    public DefaultTableModel usersModel;
    private String[] usersCol = {"Name", "UserId", "UID"};
    
    boolean attendanceSync = false;
    public List<Attendance> attendances;
    public DefaultTableModel attendanceModel;
    private String[] attendanceCol = {"Name", "UID", "Bio. IP", "Timestamp", "Type"};
    
    private List<String> biometricIps;
    public int ipIndex, ipsize;
    
    public Calisto() {
        initComponents();
        setLocationRelativeTo(this);
        DefaultCaret caretAttendanceLogs = (DefaultCaret)attendanceLogs.getCaret();
        caretAttendanceLogs.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        
        DefaultCaret caretLeaveCreditLogs = (DefaultCaret)leaveCreditLogs.getCaret();
        caretLeaveCreditLogs.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
        
        db = new DatabaseConnection();
        connection = db.getDbConnectionFromDatabase(serverIp.getText(), "hrs", "sa", "BIR159!@#po");
        
        retrofitBuilder = new RetrofitBuilder(serverIp.getText());
        requestPlaceHolder = retrofitBuilder.getRetrofit().create(RequestPlaceHolder.class);
        
        usersList = new ArrayList<>();
        attendances = new ArrayList<>();
        biometricIps = new ArrayList<>();
        
        leaveCreditMonthlyWatcher();
        leaveCreditYearlyWatcher();
        
        fetchBiometricUsers("192.168.10.39");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        serverIp = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        bioIps = new javax.swing.JTextField();
        attendanceSyncButton = new javax.swing.JButton();
        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        bioUsersLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        usersTable = new javax.swing.JTable();
        usersSyncLabel = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        usersLogs = new javax.swing.JTextArea();
        jPanel4 = new javax.swing.JPanel();
        attendanceLabel = new javax.swing.JLabel();
        attendanceSyncLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        attendanceTable = new javax.swing.JTable();
        jScrollPane3 = new javax.swing.JScrollPane();
        attendanceLogs = new javax.swing.JTextArea();
        attendanceLabel1 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        leaveCreditLogs = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Arial", 1, 18)); // NOI18N
        jLabel1.setText("Hi, I'm Calisto!");

        jLabel2.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        jLabel2.setText("I'm an AI dedicated to manage and optimize the HR and Payroll system of BOHECO I. Please don't close or terminate me in order for me to do my job.");

        serverIp.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        serverIp.setText("192.168.10.161");

        jLabel4.setFont(new java.awt.Font("Arial", 2, 11)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(102, 102, 102));
        jLabel4.setText("Main Server IP");

        jLabel5.setFont(new java.awt.Font("Arial", 2, 11)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(102, 102, 102));
        jLabel5.setText("Biometric IPS (Separate by Comma)");

        bioIps.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        bioIps.setText("192.168.10.39, 192.168.11.50");

        attendanceSyncButton.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        attendanceSyncButton.setText("Start Sync");
        attendanceSyncButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                attendanceSyncButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(serverIp, javax.swing.GroupLayout.PREFERRED_SIZE, 163, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(bioIps))
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(attendanceSyncButton)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(serverIp, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4)
                            .addComponent(jLabel5)
                            .addComponent(bioIps, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(attendanceSyncButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        jSplitPane1.setDividerLocation(500);
        jSplitPane1.setDividerSize(3);

        bioUsersLabel.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        bioUsersLabel.setText("Biometric Users");

        usersTable.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        usersTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        usersTable.setRowHeight(22);
        jScrollPane1.setViewportView(usersTable);

        usersSyncLabel.setFont(new java.awt.Font("Arial", 2, 12)); // NOI18N

        usersLogs.setColumns(20);
        usersLogs.setRows(5);
        jScrollPane4.setViewportView(usersLogs);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 479, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(bioUsersLabel)
                            .addComponent(usersSyncLabel))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jScrollPane4, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(bioUsersLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(usersSyncLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 537, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jSplitPane1.setLeftComponent(jPanel1);

        attendanceLabel.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        attendanceLabel.setText("Fingerprint Attendance Logs");

        attendanceSyncLabel.setFont(new java.awt.Font("Arial", 2, 12)); // NOI18N

        attendanceTable.setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        attendanceTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {},
                {},
                {},
                {}
            },
            new String [] {

            }
        ));
        attendanceTable.setRowHeight(22);
        jScrollPane2.setViewportView(attendanceTable);

        attendanceLogs.setColumns(20);
        attendanceLogs.setLineWrap(true);
        attendanceLogs.setRows(5);
        jScrollPane3.setViewportView(attendanceLogs);

        attendanceLabel1.setFont(new java.awt.Font("Arial", 1, 12)); // NOI18N
        attendanceLabel1.setText("Leave Credit Assistant Logs (runs every hour)");

        leaveCreditLogs.setColumns(20);
        leaveCreditLogs.setLineWrap(true);
        leaveCreditLogs.setRows(5);
        jScrollPane5.setViewportView(leaveCreditLogs);

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE)
                    .addComponent(jScrollPane3)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(attendanceLabel)
                            .addComponent(attendanceSyncLabel))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(attendanceLabel1)
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 352, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(attendanceLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(attendanceSyncLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(attendanceLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane5)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 516, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jSplitPane1.setRightComponent(jPanel4);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jSplitPane1))
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, 106, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void attendanceSyncButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_attendanceSyncButtonActionPerformed
        if (attendanceSync) {
            attendanceSync = false;
            attendanceSyncButton.setBackground(Color.RED);
            attendanceSyncButton.setText("Start Sync");
        } else {
            attendanceSync = true;
            attendanceSyncButton.setBackground(Color.decode("#00988b"));
            attendanceSyncButton.setText("Pause");
            
            biometricIps.clear();
            
            String bIps = bioIps.getText();
            if (bIps != null || !bIps.isEmpty()) {
                String ipSplit[] = bIps.split(",");
                for (int i=0; i<ipSplit.length; i++) {
                    biometricIps.add(ipSplit[i].trim());
                }
            }
            
            ipsize = biometricIps.size();
            if (ipsize > 0) {
                ipIndex = 0;
                
                fetchBiometricAttendances(biometricIps.get(ipIndex));
            }
        }
    }//GEN-LAST:event_attendanceSyncButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Calisto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Calisto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Calisto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Calisto.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Calisto().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel attendanceLabel;
    private javax.swing.JLabel attendanceLabel1;
    private javax.swing.JTextArea attendanceLogs;
    private javax.swing.JButton attendanceSyncButton;
    private javax.swing.JLabel attendanceSyncLabel;
    private javax.swing.JTable attendanceTable;
    private javax.swing.JTextField bioIps;
    private javax.swing.JLabel bioUsersLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextArea leaveCreditLogs;
    private javax.swing.JTextField serverIp;
    private javax.swing.JTextArea usersLogs;
    private javax.swing.JLabel usersSyncLabel;
    private javax.swing.JTable usersTable;
    // End of variables declaration//GEN-END:variables

    public void fetchBiometricUsers(String ipOfBiometrics) {
        try {
            usersSyncLabel.setText("Syncing from Biometrics (BIOMETRIC: " + ipOfBiometrics + ")...");
            Call<List<BiometricUsersResponse>> usersCall = requestPlaceHolder.getUsers(ipOfBiometrics);
            
            usersCall.enqueue(new Callback<List<BiometricUsersResponse>>() {
                @Override
                public void onResponse(Call<List<BiometricUsersResponse>> call, Response<List<BiometricUsersResponse>> rspns) {
                    if (rspns.isSuccessful()) {
                        usersSyncLabel.setText("Inserting data to database (BIOMETRIC: " + ipOfBiometrics + ")...");
                        List<BiometricUsersResponse> users = rspns.body();
                        
                        for (int i=0; i<users.size(); i++) {
                            BiometricUsers bioUser = new BiometricUsers(
                                    IDGenerator.generateIDandRandString(),
                                    users.get(i).getUid(),
                                    users.get(i).getName(),
                                    users.get(i).getUserid(),
                                    users.get(i).getRole(),
                                    null,
                                    IDGenerator.getCurrentTimestamp(),
                                    IDGenerator.getCurrentTimestamp()
                            );
                            
                            if (BiometricUsersDao.getOneByNameAndUserId(connection, bioUser.getName(), bioUser.getUserId()) != null) {
                                System.out.println("Skipped, already exists in DB: User " + bioUser.getName());
                            } else {
                                BiometricUsersDao.insert(connection, bioUser);
                            }
                        }
                        usersSyncLabel.setText("Syncing done (BIOMETRIC: " + ipOfBiometrics + ")!");
                        showUsersTable();
                    } else {
                        Notifiers.showMessage("Error getting users", "I can't get the bioimetric users (BIOMETRIC: " + ipOfBiometrics + "). \n" + rspns.message() + " \n" + rspns.body(), JOptionPane.ERROR_MESSAGE);
                    }
                }

                @Override
                public void onFailure(Call<List<BiometricUsersResponse>> call, Throwable thrwbl) {
                    Notifiers.showMessage("Error getting users (BIOMETRIC: " + ipOfBiometrics + ")", thrwbl.getMessage(), JOptionPane.ERROR_MESSAGE);
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public void showUsersTable() {
        try {
            usersList.clear();
            
            usersList.addAll(BiometricUsersDao.getAll(connection));
            
            int usersSize = usersList.size();
            Object[][] data = new Object[usersSize][usersCol.length];
            for (int i=0; i<usersSize; i++) {
                data[i][0] = usersList.get(i).getName();
                data[i][1] = usersList.get(i).getUserId();
                data[i][2] = usersList.get(i).getUID();
            }
            
            usersModel = new DefaultTableModel(data, usersCol);
            
            usersTable.setModel(usersModel);
            bioUsersLabel.setText("Biometric Users Registered (" + usersSize + " users)");
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error fetching all users", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
    
    public void fetchBiometricAttendances(String ipOfBiometrics) {
        try {            
            attendanceSyncLabel.setText("Syncing from Biometrics (BIOMETRIC: " + ipOfBiometrics + ")...");
            attendanceLogs.append("\nINFO: Syncing from Biometrics (BIOMETRIC: " + ipOfBiometrics + ")");
//            attendanceLogs.setCaretPosition(attendanceLogs.getDocument().getLength());
            Call<List<AttendanceResponse>> attendanceCall = requestPlaceHolder.getAttendance(ipOfBiometrics);
            
            attendanceCall.enqueue(new Callback<List<AttendanceResponse>>() {
                @Override
                public void onResponse(Call<List<AttendanceResponse>> call, Response<List<AttendanceResponse>> rspns) {
                    if (rspns.isSuccessful()) {
                        attendanceSyncLabel.setText("Inserting data to database (BIOMETRIC: " + ipOfBiometrics + ")...");
                        attendanceLogs.append("\nINFO: Inserting data to database (BIOMETRIC: " + ipOfBiometrics + ")");
//                        attendanceLogs.setCaretPosition(attendanceLogs.getDocument().getLength());
                        List<AttendanceResponse> att = rspns.body();
                        
                        int size = att.size();
                        
                        for (int i=0; i<size; i++) {
                            String type = "";
                            String uid = att.get(i).getId();
                            PayrollSchedules shift = PayrollSchedulesDao.getOnByEmployeeBioId(connection, uid);
                            
                            Date bioTimestamp = IDGenerator.parseTimestamp(att.get(i).getTimestamp());
                            String bioDate = IDGenerator.parseDate(att.get(i).getTimestamp());
                            if (shift != null) {
                                if (shift.getStartTime() != null && shift.getEndTime() != null) {
                                    Date startTime = IDGenerator.parseTimestamp(IDGenerator.addMinutes(bioDate + " " + IDGenerator.parseTime(shift.getStartTime()), 120));
                                    Date breakStart = IDGenerator.parseTimestamp(bioDate + " " + IDGenerator.parseTime(shift.getBreakStart()));
                                    Date breakMid = IDGenerator.parseTimestamp(IDGenerator.addMinutes(bioDate + " " + IDGenerator.parseTime(shift.getBreakStart()), 30));
                                    Date breakEnd = IDGenerator.parseTimestamp(IDGenerator.addMinutes(bioDate + " " + IDGenerator.parseTime(shift.getBreakEnd()), 120));
                                    if (bioTimestamp.before(startTime)) {
                                        type = "AM IN";
                                    } else if (bioTimestamp.after(breakStart) && bioTimestamp.before(breakMid)) {
                                        type = "AM OUT";
                                    } else if (bioTimestamp.after(breakMid) && bioTimestamp.before(breakEnd)) {
                                        type = "PM IN";
                                    } else if (bioTimestamp.after(breakEnd)) {
                                        type = "PM OUT";
                                    } else {
                                        type = "AMBIGUOS";
                                    }
                                } else {
                                    Date startTime = IDGenerator.parseTimestamp(IDGenerator.addMinutes(bioDate + " " + IDGenerator.parseTime(shift.getStartTime()), 120));
                                    Date endTime = IDGenerator.parseTimestamp(IDGenerator.addMinutes(bioDate + " " + IDGenerator.parseTime(shift.getEndTime()), -120));
                                    if (bioTimestamp.before(startTime)) {
                                        type = "AM IN";
                                    } else if (bioTimestamp.after(endTime)) {
                                        type = "PM OUT";
                                    } else {
                                        type = "AMBIGUOS";
                                    }
                                } 
                            } else {
                                type = "AMBIGUOS";
                            }
                            Attendance attendance = new Attendance(
                                    IDGenerator.generateIDandRandString(),
                                    att.get(i).getId(),
                                    null,
                                    null,
                                    att.get(i).getTimestamp(),
                                    att.get(i).getState(),
                                    att.get(i).getUid(),
                                    IDGenerator.getCurrentTimestamp(),
                                    IDGenerator.getCurrentTimestamp(),
                                    ipOfBiometrics,
                                    type
                            );
                            
                            if (AttendanceDao.getOneByBioUserIdAndTimestamp(connection, attendance.getBiometricUserId(), attendance.getTimestamp()) != null) {
                                System.out.println("Skipped, already exists in DB: USER ID " + attendance.getBiometricUserId() + ", TIME: " + attendance.getTimestamp());
                            } else {
                                AttendanceDao.insert(connection, attendance);
                            }
                        }
                        attendanceSyncLabel.setText("Syncing done (BIOMETRIC: " + ipOfBiometrics + ")");
                        attendanceLogs.append("\nSUCCESS: Syncing done (BIOMETRIC: " + ipOfBiometrics + ")");
//                        attendanceLogs.setCaretPosition(attendanceLogs.getDocument().getLength());
                        showAttendanceTable();
                        
                        if (attendanceSync) {
                            if (ipIndex < (ipsize-1)) {
                                ipIndex++;
                            } else {
                                ipIndex = 0;
                            }
                            
                            fetchBiometricAttendances(biometricIps.get(ipIndex));
                        }
                    } else {
                        if (attendanceSync) {
                            if (ipIndex < (ipsize-1)) {
                                ipIndex++;
                            } else {
                                ipIndex = 0;
                            }
                            
                            fetchBiometricAttendances(biometricIps.get(ipIndex));
                        }
                        attendanceLogs.append("\nERROR: I can't get the bioimetric attendance  (BIOMETRIC: " + ipOfBiometrics + "). " + rspns.message() + " : " + rspns.raw());
//                        attendanceLogs.setCaretPosition(attendanceLogs.getDocument().getLength());
//                        Notifiers.showMessage("Error getting attendance", "I can't get the bioimetric attendance  (BIOMETRIC: " + ipOfBiometrics + "). \n" + rspns.message() + " \n" + rspns.body(), JOptionPane.ERROR_MESSAGE);
                    }
                }

                @Override
                public void onFailure(Call<List<AttendanceResponse>> call, Throwable thrwbl) {
                    if (attendanceSync) {
                        if (ipIndex < (ipsize-1)) {
                            ipIndex++;
                        } else {
                            ipIndex = 0;
                        }

                        fetchBiometricAttendances(biometricIps.get(ipIndex));
                    }
                    attendanceLogs.append("\nERROR:  (BIOMETRIC: " + ipOfBiometrics + "). " + thrwbl.getMessage());
//                    Notifiers.showMessage("Error getting attendance (BIOMETRIC: " + ipOfBiometrics + ")", thrwbl.getMessage(), JOptionPane.ERROR_MESSAGE);
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public void showAttendanceTable() {
        try {
            attendances.clear();
            
            attendances.addAll(AttendanceDao.getAll(connection));
            
            int attendanceSize = attendances.size();
            Object[][] data = new Object[attendanceSize][attendanceCol.length];
            for (int i=0; i<attendanceSize; i++) {
                data[i][0] = attendances.get(i).getEmployeeId();
                data[i][1] = attendances.get(i).getBiometricUserId();
                data[i][2] = attendances.get(i).getDeviceIp();
                data[i][3] = attendances.get(i).getTimestamp();
                data[i][4] = attendances.get(i).getType();
            }
            
            attendanceModel = new DefaultTableModel(data, attendanceCol);
            
            attendanceTable.setModel(attendanceModel);
            attendanceLabel.setText("Biometric Attendances fetched (" + attendanceSize + " rows)");
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error fetching all attendances", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
    
    public void leaveCreditMonthlyWatcher() {
        try {
            Timer t = new Timer();  
            TimerTask tt = new TimerTask() {  
                @Override  
                public void run() {  
                   String dayDate = IDGenerator.getDayDate();
            
                    if (dayDate.equals("01")) {
                        System.out.println("Leave credit processing started: " + dayDate);
                        leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #: Leave Credit Assistant starting\n");
                        leaveCreditMonthlyAssistant();
                    } else {
                        System.out.println("Day skipped for leave processing: " + dayDate);
                        leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #: Day skipped for leave processing (" + dayDate + ")\n");
                    } 
                };  
            };  
            t.scheduleAtFixedRate(tt, new Date(), 3600000); 
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error updating leave credits", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
    
    public void leaveCreditYearlyWatcher() {
        try {
            Timer t = new Timer();  
            TimerTask tt = new TimerTask() {  
                @Override  
                public void run() {  
                   leaveCreditYearlyAssistant();
                };  
            };  
            t.scheduleAtFixedRate(tt, new Date(), 3650000); 
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error updating leave credits yearly", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
    
    public void leaveCreditMonthlyAssistant() {
        try {
            leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #: Calisto starting to assess leave credits\n");
            List<Employees> employees = EmployeesDao.getAll(connection);
            int size = employees.size();
            
            String month = IDGenerator.getMonth();
            String year = IDGenerator.getYear();
            
            for (int i=0; i<size; i++) {
                Employees employee = employees.get(i);
                LeaveBalances leaveBalance = LeaveBalancesDao.getOneByEmployeeId(connection, employee.getId());
                
                if (leaveBalance != null) {                    
                    /**
                     * ======================================
                     * UPDATE MONTHLY
                     * ======================================
                     */
                    if (leaveBalance.getMonth().equals(month)) {
                        // IF LEAVE FOR THIS MONTH EXISTS, DO NOT UPDATE BALANCE
                    } else {
                        double vacation = Double.valueOf(leaveBalance.getVacation()) + 1.25;
                        double sick = Double.valueOf(leaveBalance.getSick()) + 1.25;
                        leaveBalance.setVacation(vacation + "");
                        leaveBalance.setSick(sick + "");
                        leaveBalance.setMonth(month);
                        LeaveBalancesDao.update(connection, leaveBalance);

                        // ADD DETAILS FOR VACATION
                        LeaveBalanceDetails details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "1.25", 
                                "Added 1.25 days to Vacation Leave credit balance for " + month + " " + year + " (current total: " + leaveBalance.getVacation() + ")", 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);

                        // ADD DETAILS FOR SICK
                        details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "1.25", 
                                "Added 1.25 days to Sick Leave credit balance for " + month + " " + year + " (current total: " + leaveBalance.getSick()+ ")", 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);
                    }
                } else {
                    // ADD NEW
                    LeaveBalances newBalance = new LeaveBalances(IDGenerator.generateIDandRandString(), 
                            employee.getId(), 
                            "0", 
                            "0", 
                            "3", 
                            "105", 
                            "120", 
                            "7", 
                            "7", 
                            null,
                            month,
                            year,
                            IDGenerator.getCurrentTimestamp(), 
                            IDGenerator.getCurrentTimestamp());
                    LeaveBalancesDao.insert(connection, newBalance);
                    
                    // ADD DETAILS
                    LeaveBalanceDetails details = new LeaveBalanceDetails(
                            IDGenerator.generateIDandRandString(), 
                            employee.getId(), 
                            "ADD", 
                            "0", 
                            "Added new leave credit data", 
                            IDGenerator.getCurrentTimestamp(), 
                            IDGenerator.getCurrentTimestamp());
                    LeaveBalanceDetailsDao.insert(connection, details);
                }
            }
            leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #| Calisto done updating leave credits.\n");
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error updating leave credits", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
    
    public void leaveCreditYearlyAssistant() {
        try {
            leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #: Calisto starting to assess leave credits (YEAR)\n");
            List<Employees> employees = EmployeesDao.getAll(connection);
            int size = employees.size();
            
            String month = IDGenerator.getMonth();
            String year = IDGenerator.getYear();
            
            for (int i=0; i<size; i++) {
                Employees employee = employees.get(i);
                LeaveBalances leaveBalance = LeaveBalancesDao.getOneByEmployeeId(connection, employee.getId());
                
                if (leaveBalance != null) {
                    /**
                     * ======================================
                     * UPDATE YEARLY
                     * ======================================
                     */
                    if (leaveBalance.getYear().equals(year)) {
                        // IF LEAVE FOR THIS YEAR EXISTS, DO NOT UPDATE BALANCE
                    } else {
                        leaveBalance.setSpecial("3");
                        leaveBalance.setMaternity("105");
                        leaveBalance.setMaternityForSoloMother("120");
                        leaveBalance.setPaternity("7");
                        leaveBalance.setSoloParent("7");
                        leaveBalance.setYear(year);
                        LeaveBalancesDao.update(connection, leaveBalance);

                        // ADD DETAILS FOR SPECIAL
                        LeaveBalanceDetails details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "3", 
                                "Added 3 days to Special Leave credit balance for " + year, 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);

                        // ADD DETAILS FOR MATERNITY
                        details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "105", 
                                "Added 105 days to Maternity Leave credit balance for " + year, 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);
                        
                        // ADD DETAILS FOR MATERNITY FOR SOLO MOTHER
                        details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "120", 
                                "Added 120 days to Maternity Leave for Solo Mother credit balance for " + year, 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);
                        
                        // ADD DETAILS FOR PATERNITY
                        details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "7", 
                                "Added 7 days to Paternity Leave credit balance for " + year, 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);
                        
                        // ADD DETAILS FOR SOLO PARENT
                        details = new LeaveBalanceDetails(
                                IDGenerator.generateIDandRandString(), 
                                employee.getId(), 
                                "ADD", 
                                "7", 
                                "Added 7 days to Solo Parent Leave credit balance for " + year, 
                                IDGenerator.getCurrentTimestamp(), 
                                IDGenerator.getCurrentTimestamp());
                        LeaveBalanceDetailsDao.insert(connection, details);
                    }
                } else {
                    // ADD NEW
                    LeaveBalances newBalance = new LeaveBalances(IDGenerator.generateIDandRandString(), 
                            employee.getId(), 
                            "0", 
                            "0", 
                            "3", 
                            "105", 
                            "120", 
                            "7", 
                            "7", 
                            null,
                            month,
                            year,
                            IDGenerator.getCurrentTimestamp(), 
                            IDGenerator.getCurrentTimestamp());
                    LeaveBalancesDao.insert(connection, newBalance);
                    
                    // ADD DETAILS
                    LeaveBalanceDetails details = new LeaveBalanceDetails(
                            IDGenerator.generateIDandRandString(), 
                            employee.getId(), 
                            "ADD", 
                            "0", 
                            "Added new leave credit data", 
                            IDGenerator.getCurrentTimestamp(), 
                            IDGenerator.getCurrentTimestamp());
                    LeaveBalanceDetailsDao.insert(connection, details);
                }
            }
            leaveCreditLogs.append(IDGenerator.getCurrentTimestamp() + " #| Calisto done updating leave credits (YEAR).\n");
        } catch (Exception e) {
            e.printStackTrace();
            Notifiers.showMessage("Error updating leave credits", e.getMessage(), JOptionPane.ERROR_MESSAGE);
        }
    }
}
